/* tslint:disable */
/* eslint-disable */
/*
Shutterstock API Explorer

The Shutterstock API provides access to Shutterstock's library of media, as well as information about customers' accounts and the contributors that provide the media.

The version of the OpenAPI document: 1.1.32


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { Audio } from '../models';
// @ts-ignore
import { AudioDataList } from '../models';
// @ts-ignore
import { AudioSearchResults } from '../models';
// @ts-ignore
import { AudioUrl } from '../models';
// @ts-ignore
import { Collection } from '../models';
// @ts-ignore
import { CollectionCreateRequest } from '../models';
// @ts-ignore
import { CollectionCreateResponse } from '../models';
// @ts-ignore
import { CollectionDataList } from '../models';
// @ts-ignore
import { CollectionItem } from '../models';
// @ts-ignore
import { CollectionItemDataList } from '../models';
// @ts-ignore
import { CollectionItemRequest } from '../models';
// @ts-ignore
import { CollectionUpdateRequest } from '../models';
// @ts-ignore
import { DownloadHistoryDataList } from '../models';
// @ts-ignore
import { GenreList } from '../models';
// @ts-ignore
import { InstrumentList } from '../models';
// @ts-ignore
import { LicenseAudio } from '../models';
// @ts-ignore
import { LicenseAudioRequest } from '../models';
// @ts-ignore
import { LicenseAudioResultDataList } from '../models';
// @ts-ignore
import { MoodList } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * AudioApi - axios parameter creator
 * @export
 */
export const AudioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint adds one or more tracks to a collection by track IDs.
         * @summary Add audio tracks to collections
         * @param {string} id Collection ID
         * @param {CollectionItemRequest} collectionItemRequest List of items to add to collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTracksToCollection: async (id: string, collectionItemRequest: CollectionItemRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addTracksToCollection', 'id', id)
            // verify required parameter 'collectionItemRequest' is not null or undefined
            assertParamExists('addTracksToCollection', 'collectionItemRequest', collectionItemRequest)
            const localVarPath = `/v2/audio/collections/{id}/items`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication customer_accessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "customer_accessCode", ["collections.edit"], configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: collectionItemRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/audio/collections/{id}/items',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(collectionItemRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint creates one or more collections (soundboxes). To add tracks, use `POST /v2/audio/collections/{id}/items`.
         * @summary Create audio collections
         * @param {CollectionCreateRequest} collectionCreateRequest Collection metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollections: async (collectionCreateRequest: CollectionCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionCreateRequest' is not null or undefined
            assertParamExists('createCollections', 'collectionCreateRequest', collectionCreateRequest)
            const localVarPath = `/v2/audio/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication customer_accessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "customer_accessCode", ["collections.edit"], configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: collectionCreateRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/audio/collections',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(collectionCreateRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deletes a collection.
         * @summary Delete audio collections
         * @param {string} id Collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCollection', 'id', id)
            const localVarPath = `/v2/audio/collections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication customer_accessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "customer_accessCode", ["collections.edit"], configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/audio/collections/{id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gets more detailed information about a collection, including the number of items in it and when it was last updated. To get the tracks in collections, use `GET /v2/audio/collections/{id}/items`.
         * @summary Get the details of audio collections
         * @param {string} id Collection ID
         * @param {Array<'share_code' | 'share_url'>} [embed] Which sharing information to include in the response, such as a URL to the collection
         * @param {string} [shareCode] Code to retrieve a shared collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionDetails: async (id: string, embed?: Array<'share_code' | 'share_url'>, shareCode?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCollectionDetails', 'id', id)
            const localVarPath = `/v2/audio/collections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication customer_accessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "customer_accessCode", ["collections.view"], configuration)
            if (embed) {
                localVarQueryParameter['embed'] = embed;
            }

            if (shareCode !== undefined) {
                localVarQueryParameter['share_code'] = shareCode;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/audio/collections/{id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint shows information about a track, including its genres, instruments, and other attributes.
         * @summary Get details about audio tracks
         * @param {number} id Audio track ID
         * @param {'minimal' | 'full'} [view] Amount of detail to render in the response
         * @param {string} [searchId] The ID of the search that is related to this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackDetails: async (id: number, view?: 'minimal' | 'full', searchId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTrackDetails', 'id', id)
            const localVarPath = `/v2/audio/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            // authentication customer_accessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "customer_accessCode", [], configuration)
            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }

            if (searchId !== undefined) {
                localVarQueryParameter['search_id'] = searchId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/audio/{id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gets licenses for one or more tracks. The download links in the response are valid for 8 hours.
         * @summary License audio tracks
         * @param {LicenseAudioRequest} licenseAudioRequest Tracks to license
         * @param {'audio_platform' | 'premier_music_basic' | 'premier_music_extended' | 'premier_music_pro' | 'premier_music_comp' | 'asset_all_music'} [license] License type
         * @param {string} [searchId] The ID of the search that led to licensing this track
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        licenseTracks: async (licenseAudioRequest: LicenseAudioRequest, license?: 'audio_platform' | 'premier_music_basic' | 'premier_music_extended' | 'premier_music_pro' | 'premier_music_comp' | 'asset_all_music', searchId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'licenseAudioRequest' is not null or undefined
            assertParamExists('licenseTracks', 'licenseAudioRequest', licenseAudioRequest)
            const localVarPath = `/v2/audio/licenses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication customer_accessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "customer_accessCode", ["licenses.create"], configuration)
            if (license !== undefined) {
                localVarQueryParameter['license'] = license;
            }

            if (searchId !== undefined) {
                localVarQueryParameter['search_id'] = searchId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: licenseAudioRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/audio/licenses',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(licenseAudioRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint lists existing licenses. You can filter the results according to the track ID to see if you have an existing license for a specific track.
         * @summary List audio licenses
         * @param {string} [audioId] Show licenses for the specified track ID
         * @param {string} [license] Restrict results by license. Prepending a &#x60;-&#x60; sign will exclude results by license
         * @param {number} [page] Page number
         * @param {number} [perPage] Number of results per page
         * @param {'newest' | 'oldest'} [sort] Sort order
         * @param {string} [username] Filter licenses by username of licensee
         * @param {string} [startDate] Show licenses created on or after the specified date
         * @param {string} [endDate] Show licenses created before the specified date
         * @param {'all' | 'downloadable' | 'non_downloadable'} [downloadAvailability] Filter licenses by download availability
         * @param {boolean} [teamHistory] Set to true to see license history for all members of your team.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAudioLicenses: async (audioId?: string, license?: string, page?: number, perPage?: number, sort?: 'newest' | 'oldest', username?: string, startDate?: string, endDate?: string, downloadAvailability?: 'all' | 'downloadable' | 'non_downloadable', teamHistory?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/audio/licenses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication customer_accessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "customer_accessCode", ["licenses.view"], configuration)
            if (audioId !== undefined) {
                localVarQueryParameter['audio_id'] = audioId;
            }

            if (license !== undefined) {
                localVarQueryParameter['license'] = license;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (downloadAvailability !== undefined) {
                localVarQueryParameter['download_availability'] = downloadAvailability;
            }

            if (teamHistory !== undefined) {
                localVarQueryParameter['team_history'] = teamHistory;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/audio/licenses',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint lists the IDs of tracks in a collection and the date that each was added.
         * @summary Get the contents of audio collections
         * @param {string} id Collection ID
         * @param {number} [page] Page number
         * @param {number} [perPage] Number of results per page
         * @param {string} [shareCode] Code to retrieve the contents of a shared collection
         * @param {'newest' | 'oldest'} [sort] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionItems: async (id: string, page?: number, perPage?: number, shareCode?: string, sort?: 'newest' | 'oldest', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listCollectionItems', 'id', id)
            const localVarPath = `/v2/audio/collections/{id}/items`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication customer_accessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "customer_accessCode", ["collections.view"], configuration)
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (shareCode !== undefined) {
                localVarQueryParameter['share_code'] = shareCode;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/audio/collections/{id}/items',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint lists your collections of audio tracks and their basic attributes.
         * @summary List audio collections
         * @param {number} [page] Page number
         * @param {number} [perPage] Number of results per page
         * @param {Array<'share_code' | 'share_url'>} [embed] Which sharing information to include in the response, such as a URL to the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections: async (page?: number, perPage?: number, embed?: Array<'share_code' | 'share_url'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/audio/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication customer_accessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "customer_accessCode", ["collections.view"], configuration)
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/audio/collections',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of all audio genres.
         * @summary List audio genres
         * @param {string} [language] Which language the genres will be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGenres: async (language?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/audio/genres`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            // authentication customer_accessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "customer_accessCode", [], configuration)
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/audio/genres',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of all audio instruments.
         * @summary List audio instruments
         * @param {string} [language] Which language the instruments will be returned in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInstruments: async (language?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/audio/instruments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            // authentication customer_accessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "customer_accessCode", [], configuration)
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/audio/instruments',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of all audio moods.
         * @summary List audio moods
         * @param {string} [language] Which language the moods will be returned in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMoods: async (language?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/audio/moods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            // authentication customer_accessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "customer_accessCode", [], configuration)
            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/audio/moods',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint lists information about one or more audio tracks, including the description and publication date.
         * @summary List audio tracks
         * @param {Array<string>} id One or more audio IDs
         * @param {'minimal' | 'full'} [view] Amount of detail to render in the response
         * @param {string} [searchId] The ID of the search that is related to this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTracks: async (id: Array<string>, view?: 'minimal' | 'full', searchId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listTracks', 'id', id)
            const localVarPath = `/v2/audio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            // authentication customer_accessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "customer_accessCode", [], configuration)
            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }

            if (searchId !== undefined) {
                localVarQueryParameter['search_id'] = searchId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/audio',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint redownloads tracks that you have already received a license for. The download links in the response are valid for 8 hours.
         * @summary Download audio tracks
         * @param {string} id License ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redownloadTracks: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('redownloadTracks', 'id', id)
            const localVarPath = `/v2/audio/licenses/{id}/downloads`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication customer_accessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "customer_accessCode", ["licenses.view"], configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/audio/licenses/{id}/downloads',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint removes one or more tracks from a collection.
         * @summary Remove audio tracks from collections
         * @param {string} id Collection ID
         * @param {Array<string>} [itemId] One or more item IDs to remove from the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTracksFromCollection: async (id: string, itemId?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeTracksFromCollection', 'id', id)
            const localVarPath = `/v2/audio/collections/{id}/items`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication customer_accessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "customer_accessCode", ["collections.edit"], configuration)
            if (itemId) {
                localVarQueryParameter['item_id'] = itemId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/audio/collections/{id}/items',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint searches for tracks. If you specify more than one search parameter, the API uses an AND condition. Array parameters can be specified multiple times; in this case, the API uses an AND or an OR condition with those values, depending on the parameter.
         * @summary Search for tracks
         * @param {Array<string>} [artists] Show tracks with one of the specified artist names or IDs
         * @param {number} [bpm] (Deprecated; use bpm_from and bpm_to instead) Show tracks with the specified beats per minute
         * @param {number} [bpmFrom] Show tracks with the specified beats per minute or faster
         * @param {number} [bpmTo] Show tracks with the specified beats per minute or slower
         * @param {number} [duration] Show tracks with the specified duration in seconds
         * @param {number} [durationFrom] Show tracks with the specified duration or longer in seconds
         * @param {number} [durationTo] Show tracks with the specified duration or shorter in seconds
         * @param {Array<string>} [genre] Show tracks with each of the specified genres; to get the list of genres, use &#x60;GET /v2/audio/genres&#x60;
         * @param {boolean} [isInstrumental] Show instrumental music only
         * @param {Array<string>} [instruments] Show tracks with each of the specified instruments; to get the list of instruments, use &#x60;GET /v2/audio/instruments&#x60;
         * @param {Array<string>} [moods] Show tracks with each of the specified moods; to get the list of moods, use &#x60;GET /v2/audio/moods&#x60;
         * @param {number} [page] Page number
         * @param {number} [perPage] Number of results per page
         * @param {string} [query] One or more search terms separated by spaces
         * @param {'score' | 'ranking_all' | 'artist' | 'title' | 'bpm' | 'freshness' | 'duration'} [sort] Sort by
         * @param {'asc' | 'desc'} [sortOrder] Sort order
         * @param {string} [vocalDescription] Show tracks with the specified vocal description (male, female)
         * @param {'minimal' | 'full'} [view] Amount of detail to render in the response
         * @param {string} [fields] Fields to display in the response; see the documentation for the fields parameter in the overview section
         * @param {'shutterstock' | 'premier'} [library] Which library to search
         * @param {string} [language] Which language to search in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTracks: async (artists?: Array<string>, bpm?: number, bpmFrom?: number, bpmTo?: number, duration?: number, durationFrom?: number, durationTo?: number, genre?: Array<string>, isInstrumental?: boolean, instruments?: Array<string>, moods?: Array<string>, page?: number, perPage?: number, query?: string, sort?: 'score' | 'ranking_all' | 'artist' | 'title' | 'bpm' | 'freshness' | 'duration', sortOrder?: 'asc' | 'desc', vocalDescription?: string, view?: 'minimal' | 'full', fields?: string, library?: 'shutterstock' | 'premier', language?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/audio/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            // authentication customer_accessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "customer_accessCode", [], configuration)
            if (artists) {
                localVarQueryParameter['artists'] = artists;
            }

            if (bpm !== undefined) {
                localVarQueryParameter['bpm'] = bpm;
            }

            if (bpmFrom !== undefined) {
                localVarQueryParameter['bpm_from'] = bpmFrom;
            }

            if (bpmTo !== undefined) {
                localVarQueryParameter['bpm_to'] = bpmTo;
            }

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }

            if (durationFrom !== undefined) {
                localVarQueryParameter['duration_from'] = durationFrom;
            }

            if (durationTo !== undefined) {
                localVarQueryParameter['duration_to'] = durationTo;
            }

            if (genre) {
                localVarQueryParameter['genre'] = genre;
            }

            if (isInstrumental !== undefined) {
                localVarQueryParameter['is_instrumental'] = isInstrumental;
            }

            if (instruments) {
                localVarQueryParameter['instruments'] = instruments;
            }

            if (moods) {
                localVarQueryParameter['moods'] = moods;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (vocalDescription !== undefined) {
                localVarQueryParameter['vocal_description'] = vocalDescription;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (library !== undefined) {
                localVarQueryParameter['library'] = library;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/audio/search',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint sets a new name for a collection.
         * @summary Rename audio collections
         * @param {string} id Collection ID
         * @param {CollectionUpdateRequest} collectionUpdateRequest Collection changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCollectionName: async (id: string, collectionUpdateRequest: CollectionUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setCollectionName', 'id', id)
            // verify required parameter 'collectionUpdateRequest' is not null or undefined
            assertParamExists('setCollectionName', 'collectionUpdateRequest', collectionUpdateRequest)
            const localVarPath = `/v2/audio/collections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication customer_accessCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "customer_accessCode", ["collections.edit"], configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: collectionUpdateRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/audio/collections/{id}',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(collectionUpdateRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AudioApi - functional programming interface
 * @export
 */
export const AudioApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AudioApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint adds one or more tracks to a collection by track IDs.
         * @summary Add audio tracks to collections
         * @param {AudioApiAddTracksToCollectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTracksToCollection(requestParameters: AudioApiAddTracksToCollectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const collectionItemRequest: CollectionItemRequest = {
                items: requestParameters.items
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTracksToCollection(requestParameters.id, collectionItemRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint creates one or more collections (soundboxes). To add tracks, use `POST /v2/audio/collections/{id}/items`.
         * @summary Create audio collections
         * @param {AudioApiCreateCollectionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollections(requestParameters: AudioApiCreateCollectionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionCreateResponse>> {
            const collectionCreateRequest: CollectionCreateRequest = {
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollections(collectionCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint deletes a collection.
         * @summary Delete audio collections
         * @param {AudioApiDeleteCollectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCollection(requestParameters: AudioApiDeleteCollectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCollection(requestParameters.id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gets more detailed information about a collection, including the number of items in it and when it was last updated. To get the tracks in collections, use `GET /v2/audio/collections/{id}/items`.
         * @summary Get the details of audio collections
         * @param {AudioApiGetCollectionDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionDetails(requestParameters: AudioApiGetCollectionDetailsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionDetails(requestParameters.id, requestParameters.embed, requestParameters.shareCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint shows information about a track, including its genres, instruments, and other attributes.
         * @summary Get details about audio tracks
         * @param {AudioApiGetTrackDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrackDetails(requestParameters: AudioApiGetTrackDetailsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Audio>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrackDetails(requestParameters.id, requestParameters.view, requestParameters.searchId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gets licenses for one or more tracks. The download links in the response are valid for 8 hours.
         * @summary License audio tracks
         * @param {AudioApiLicenseTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async licenseTracks(requestParameters: AudioApiLicenseTracksRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LicenseAudioResultDataList>> {
            const licenseAudioRequest: LicenseAudioRequest = {
                audio: requestParameters.audio
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.licenseTracks(licenseAudioRequest, requestParameters.license, requestParameters.searchId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint lists existing licenses. You can filter the results according to the track ID to see if you have an existing license for a specific track.
         * @summary List audio licenses
         * @param {AudioApiListAudioLicensesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAudioLicenses(requestParameters: AudioApiListAudioLicensesRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DownloadHistoryDataList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAudioLicenses(requestParameters.audioId, requestParameters.license, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.username, requestParameters.startDate, requestParameters.endDate, requestParameters.downloadAvailability, requestParameters.teamHistory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint lists the IDs of tracks in a collection and the date that each was added.
         * @summary Get the contents of audio collections
         * @param {AudioApiListCollectionItemsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCollectionItems(requestParameters: AudioApiListCollectionItemsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionItemDataList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCollectionItems(requestParameters.id, requestParameters.page, requestParameters.perPage, requestParameters.shareCode, requestParameters.sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint lists your collections of audio tracks and their basic attributes.
         * @summary List audio collections
         * @param {AudioApiListCollectionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCollections(requestParameters: AudioApiListCollectionsRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionDataList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCollections(requestParameters.page, requestParameters.perPage, requestParameters.embed, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of all audio genres.
         * @summary List audio genres
         * @param {AudioApiListGenresRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGenres(requestParameters: AudioApiListGenresRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenreList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGenres(requestParameters.language, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of all audio instruments.
         * @summary List audio instruments
         * @param {AudioApiListInstrumentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInstruments(requestParameters: AudioApiListInstrumentsRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstrumentList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInstruments(requestParameters.language, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of all audio moods.
         * @summary List audio moods
         * @param {AudioApiListMoodsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMoods(requestParameters: AudioApiListMoodsRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MoodList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMoods(requestParameters.language, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint lists information about one or more audio tracks, including the description and publication date.
         * @summary List audio tracks
         * @param {AudioApiListTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTracks(requestParameters: AudioApiListTracksRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AudioDataList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTracks(requestParameters.id, requestParameters.view, requestParameters.searchId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint redownloads tracks that you have already received a license for. The download links in the response are valid for 8 hours.
         * @summary Download audio tracks
         * @param {AudioApiRedownloadTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redownloadTracks(requestParameters: AudioApiRedownloadTracksRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AudioUrl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redownloadTracks(requestParameters.id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint removes one or more tracks from a collection.
         * @summary Remove audio tracks from collections
         * @param {AudioApiRemoveTracksFromCollectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTracksFromCollection(requestParameters: AudioApiRemoveTracksFromCollectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTracksFromCollection(requestParameters.id, requestParameters.itemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint searches for tracks. If you specify more than one search parameter, the API uses an AND condition. Array parameters can be specified multiple times; in this case, the API uses an AND or an OR condition with those values, depending on the parameter.
         * @summary Search for tracks
         * @param {AudioApiSearchTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTracks(requestParameters: AudioApiSearchTracksRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AudioSearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTracks(requestParameters.artists, requestParameters.bpm, requestParameters.bpmFrom, requestParameters.bpmTo, requestParameters.duration, requestParameters.durationFrom, requestParameters.durationTo, requestParameters.genre, requestParameters.isInstrumental, requestParameters.instruments, requestParameters.moods, requestParameters.page, requestParameters.perPage, requestParameters.query, requestParameters.sort, requestParameters.sortOrder, requestParameters.vocalDescription, requestParameters.view, requestParameters.fields, requestParameters.library, requestParameters.language, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint sets a new name for a collection.
         * @summary Rename audio collections
         * @param {AudioApiSetCollectionNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setCollectionName(requestParameters: AudioApiSetCollectionNameRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const collectionUpdateRequest: CollectionUpdateRequest = {
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCollectionName(requestParameters.id, collectionUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AudioApi - factory interface
 * @export
 */
export const AudioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AudioApiFp(configuration)
    return {
        /**
         * This endpoint adds one or more tracks to a collection by track IDs.
         * @summary Add audio tracks to collections
         * @param {AudioApiAddTracksToCollectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTracksToCollection(requestParameters: AudioApiAddTracksToCollectionRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addTracksToCollection(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint creates one or more collections (soundboxes). To add tracks, use `POST /v2/audio/collections/{id}/items`.
         * @summary Create audio collections
         * @param {AudioApiCreateCollectionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollections(requestParameters: AudioApiCreateCollectionsRequest, options?: AxiosRequestConfig): AxiosPromise<CollectionCreateResponse> {
            return localVarFp.createCollections(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint deletes a collection.
         * @summary Delete audio collections
         * @param {AudioApiDeleteCollectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection(requestParameters: AudioApiDeleteCollectionRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCollection(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gets more detailed information about a collection, including the number of items in it and when it was last updated. To get the tracks in collections, use `GET /v2/audio/collections/{id}/items`.
         * @summary Get the details of audio collections
         * @param {AudioApiGetCollectionDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionDetails(requestParameters: AudioApiGetCollectionDetailsRequest, options?: AxiosRequestConfig): AxiosPromise<Collection> {
            return localVarFp.getCollectionDetails(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint shows information about a track, including its genres, instruments, and other attributes.
         * @summary Get details about audio tracks
         * @param {AudioApiGetTrackDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackDetails(requestParameters: AudioApiGetTrackDetailsRequest, options?: AxiosRequestConfig): AxiosPromise<Audio> {
            return localVarFp.getTrackDetails(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gets licenses for one or more tracks. The download links in the response are valid for 8 hours.
         * @summary License audio tracks
         * @param {AudioApiLicenseTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        licenseTracks(requestParameters: AudioApiLicenseTracksRequest, options?: AxiosRequestConfig): AxiosPromise<LicenseAudioResultDataList> {
            return localVarFp.licenseTracks(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint lists existing licenses. You can filter the results according to the track ID to see if you have an existing license for a specific track.
         * @summary List audio licenses
         * @param {AudioApiListAudioLicensesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAudioLicenses(requestParameters: AudioApiListAudioLicensesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<DownloadHistoryDataList> {
            return localVarFp.listAudioLicenses(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint lists the IDs of tracks in a collection and the date that each was added.
         * @summary Get the contents of audio collections
         * @param {AudioApiListCollectionItemsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionItems(requestParameters: AudioApiListCollectionItemsRequest, options?: AxiosRequestConfig): AxiosPromise<CollectionItemDataList> {
            return localVarFp.listCollectionItems(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint lists your collections of audio tracks and their basic attributes.
         * @summary List audio collections
         * @param {AudioApiListCollectionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections(requestParameters: AudioApiListCollectionsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CollectionDataList> {
            return localVarFp.listCollections(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of all audio genres.
         * @summary List audio genres
         * @param {AudioApiListGenresRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGenres(requestParameters: AudioApiListGenresRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GenreList> {
            return localVarFp.listGenres(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of all audio instruments.
         * @summary List audio instruments
         * @param {AudioApiListInstrumentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInstruments(requestParameters: AudioApiListInstrumentsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<InstrumentList> {
            return localVarFp.listInstruments(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of all audio moods.
         * @summary List audio moods
         * @param {AudioApiListMoodsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMoods(requestParameters: AudioApiListMoodsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<MoodList> {
            return localVarFp.listMoods(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint lists information about one or more audio tracks, including the description and publication date.
         * @summary List audio tracks
         * @param {AudioApiListTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTracks(requestParameters: AudioApiListTracksRequest, options?: AxiosRequestConfig): AxiosPromise<AudioDataList> {
            return localVarFp.listTracks(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint redownloads tracks that you have already received a license for. The download links in the response are valid for 8 hours.
         * @summary Download audio tracks
         * @param {AudioApiRedownloadTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redownloadTracks(requestParameters: AudioApiRedownloadTracksRequest, options?: AxiosRequestConfig): AxiosPromise<AudioUrl> {
            return localVarFp.redownloadTracks(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint removes one or more tracks from a collection.
         * @summary Remove audio tracks from collections
         * @param {AudioApiRemoveTracksFromCollectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTracksFromCollection(requestParameters: AudioApiRemoveTracksFromCollectionRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeTracksFromCollection(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint searches for tracks. If you specify more than one search parameter, the API uses an AND condition. Array parameters can be specified multiple times; in this case, the API uses an AND or an OR condition with those values, depending on the parameter.
         * @summary Search for tracks
         * @param {AudioApiSearchTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTracks(requestParameters: AudioApiSearchTracksRequest, options?: AxiosRequestConfig): AxiosPromise<AudioSearchResults> {
            return localVarFp.searchTracks(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint sets a new name for a collection.
         * @summary Rename audio collections
         * @param {AudioApiSetCollectionNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCollectionName(requestParameters: AudioApiSetCollectionNameRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setCollectionName(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addTracksToCollection operation in AudioApi.
 * @export
 * @interface AudioApiAddTracksToCollectionRequest
 */
export type AudioApiAddTracksToCollectionRequest = {
    
    /**
    * Collection ID
    * @type {string}
    * @memberof AudioApiAddTracksToCollection
    */
    readonly id: string
    
} & CollectionItemRequest

/**
 * Request parameters for createCollections operation in AudioApi.
 * @export
 * @interface AudioApiCreateCollectionsRequest
 */
export type AudioApiCreateCollectionsRequest = {
    
} & CollectionCreateRequest

/**
 * Request parameters for deleteCollection operation in AudioApi.
 * @export
 * @interface AudioApiDeleteCollectionRequest
 */
export type AudioApiDeleteCollectionRequest = {
    
    /**
    * Collection ID
    * @type {string}
    * @memberof AudioApiDeleteCollection
    */
    readonly id: string
    
}

/**
 * Request parameters for getCollectionDetails operation in AudioApi.
 * @export
 * @interface AudioApiGetCollectionDetailsRequest
 */
export type AudioApiGetCollectionDetailsRequest = {
    
    /**
    * Collection ID
    * @type {string}
    * @memberof AudioApiGetCollectionDetails
    */
    readonly id: string
    
    /**
    * Which sharing information to include in the response, such as a URL to the collection
    * @type {Array<'share_code' | 'share_url'>}
    * @memberof AudioApiGetCollectionDetails
    */
    readonly embed?: Array<'share_code' | 'share_url'>
    
    /**
    * Code to retrieve a shared collection
    * @type {string}
    * @memberof AudioApiGetCollectionDetails
    */
    readonly shareCode?: string
    
}

/**
 * Request parameters for getTrackDetails operation in AudioApi.
 * @export
 * @interface AudioApiGetTrackDetailsRequest
 */
export type AudioApiGetTrackDetailsRequest = {
    
    /**
    * Audio track ID
    * @type {number}
    * @memberof AudioApiGetTrackDetails
    */
    readonly id: number
    
    /**
    * Amount of detail to render in the response
    * @type {'minimal' | 'full'}
    * @memberof AudioApiGetTrackDetails
    */
    readonly view?: 'minimal' | 'full'
    
    /**
    * The ID of the search that is related to this request
    * @type {string}
    * @memberof AudioApiGetTrackDetails
    */
    readonly searchId?: string
    
}

/**
 * Request parameters for licenseTracks operation in AudioApi.
 * @export
 * @interface AudioApiLicenseTracksRequest
 */
export type AudioApiLicenseTracksRequest = {
    
    /**
    * License type
    * @type {'audio_platform' | 'premier_music_basic' | 'premier_music_extended' | 'premier_music_pro' | 'premier_music_comp' | 'asset_all_music'}
    * @memberof AudioApiLicenseTracks
    */
    readonly license?: 'audio_platform' | 'premier_music_basic' | 'premier_music_extended' | 'premier_music_pro' | 'premier_music_comp' | 'asset_all_music'
    
    /**
    * The ID of the search that led to licensing this track
    * @type {string}
    * @memberof AudioApiLicenseTracks
    */
    readonly searchId?: string
    
} & LicenseAudioRequest

/**
 * Request parameters for listAudioLicenses operation in AudioApi.
 * @export
 * @interface AudioApiListAudioLicensesRequest
 */
export type AudioApiListAudioLicensesRequest = {
    
    /**
    * Show licenses for the specified track ID
    * @type {string}
    * @memberof AudioApiListAudioLicenses
    */
    readonly audioId?: string
    
    /**
    * Restrict results by license. Prepending a `-` sign will exclude results by license
    * @type {string}
    * @memberof AudioApiListAudioLicenses
    */
    readonly license?: string
    
    /**
    * Page number
    * @type {number}
    * @memberof AudioApiListAudioLicenses
    */
    readonly page?: number
    
    /**
    * Number of results per page
    * @type {number}
    * @memberof AudioApiListAudioLicenses
    */
    readonly perPage?: number
    
    /**
    * Sort order
    * @type {'newest' | 'oldest'}
    * @memberof AudioApiListAudioLicenses
    */
    readonly sort?: 'newest' | 'oldest'
    
    /**
    * Filter licenses by username of licensee
    * @type {string}
    * @memberof AudioApiListAudioLicenses
    */
    readonly username?: string
    
    /**
    * Show licenses created on or after the specified date
    * @type {string}
    * @memberof AudioApiListAudioLicenses
    */
    readonly startDate?: string
    
    /**
    * Show licenses created before the specified date
    * @type {string}
    * @memberof AudioApiListAudioLicenses
    */
    readonly endDate?: string
    
    /**
    * Filter licenses by download availability
    * @type {'all' | 'downloadable' | 'non_downloadable'}
    * @memberof AudioApiListAudioLicenses
    */
    readonly downloadAvailability?: 'all' | 'downloadable' | 'non_downloadable'
    
    /**
    * Set to true to see license history for all members of your team.
    * @type {boolean}
    * @memberof AudioApiListAudioLicenses
    */
    readonly teamHistory?: boolean
    
}

/**
 * Request parameters for listCollectionItems operation in AudioApi.
 * @export
 * @interface AudioApiListCollectionItemsRequest
 */
export type AudioApiListCollectionItemsRequest = {
    
    /**
    * Collection ID
    * @type {string}
    * @memberof AudioApiListCollectionItems
    */
    readonly id: string
    
    /**
    * Page number
    * @type {number}
    * @memberof AudioApiListCollectionItems
    */
    readonly page?: number
    
    /**
    * Number of results per page
    * @type {number}
    * @memberof AudioApiListCollectionItems
    */
    readonly perPage?: number
    
    /**
    * Code to retrieve the contents of a shared collection
    * @type {string}
    * @memberof AudioApiListCollectionItems
    */
    readonly shareCode?: string
    
    /**
    * Sort order
    * @type {'newest' | 'oldest'}
    * @memberof AudioApiListCollectionItems
    */
    readonly sort?: 'newest' | 'oldest'
    
}

/**
 * Request parameters for listCollections operation in AudioApi.
 * @export
 * @interface AudioApiListCollectionsRequest
 */
export type AudioApiListCollectionsRequest = {
    
    /**
    * Page number
    * @type {number}
    * @memberof AudioApiListCollections
    */
    readonly page?: number
    
    /**
    * Number of results per page
    * @type {number}
    * @memberof AudioApiListCollections
    */
    readonly perPage?: number
    
    /**
    * Which sharing information to include in the response, such as a URL to the collection
    * @type {Array<'share_code' | 'share_url'>}
    * @memberof AudioApiListCollections
    */
    readonly embed?: Array<'share_code' | 'share_url'>
    
}

/**
 * Request parameters for listGenres operation in AudioApi.
 * @export
 * @interface AudioApiListGenresRequest
 */
export type AudioApiListGenresRequest = {
    
    /**
    * Which language the genres will be returned
    * @type {string}
    * @memberof AudioApiListGenres
    */
    readonly language?: string
    
}

/**
 * Request parameters for listInstruments operation in AudioApi.
 * @export
 * @interface AudioApiListInstrumentsRequest
 */
export type AudioApiListInstrumentsRequest = {
    
    /**
    * Which language the instruments will be returned in
    * @type {string}
    * @memberof AudioApiListInstruments
    */
    readonly language?: string
    
}

/**
 * Request parameters for listMoods operation in AudioApi.
 * @export
 * @interface AudioApiListMoodsRequest
 */
export type AudioApiListMoodsRequest = {
    
    /**
    * Which language the moods will be returned in
    * @type {string}
    * @memberof AudioApiListMoods
    */
    readonly language?: string
    
}

/**
 * Request parameters for listTracks operation in AudioApi.
 * @export
 * @interface AudioApiListTracksRequest
 */
export type AudioApiListTracksRequest = {
    
    /**
    * One or more audio IDs
    * @type {Array<string>}
    * @memberof AudioApiListTracks
    */
    readonly id: Array<string>
    
    /**
    * Amount of detail to render in the response
    * @type {'minimal' | 'full'}
    * @memberof AudioApiListTracks
    */
    readonly view?: 'minimal' | 'full'
    
    /**
    * The ID of the search that is related to this request
    * @type {string}
    * @memberof AudioApiListTracks
    */
    readonly searchId?: string
    
}

/**
 * Request parameters for redownloadTracks operation in AudioApi.
 * @export
 * @interface AudioApiRedownloadTracksRequest
 */
export type AudioApiRedownloadTracksRequest = {
    
    /**
    * License ID
    * @type {string}
    * @memberof AudioApiRedownloadTracks
    */
    readonly id: string
    
}

/**
 * Request parameters for removeTracksFromCollection operation in AudioApi.
 * @export
 * @interface AudioApiRemoveTracksFromCollectionRequest
 */
export type AudioApiRemoveTracksFromCollectionRequest = {
    
    /**
    * Collection ID
    * @type {string}
    * @memberof AudioApiRemoveTracksFromCollection
    */
    readonly id: string
    
    /**
    * One or more item IDs to remove from the collection
    * @type {Array<string>}
    * @memberof AudioApiRemoveTracksFromCollection
    */
    readonly itemId?: Array<string>
    
}

/**
 * Request parameters for searchTracks operation in AudioApi.
 * @export
 * @interface AudioApiSearchTracksRequest
 */
export type AudioApiSearchTracksRequest = {
    
    /**
    * Show tracks with one of the specified artist names or IDs
    * @type {Array<string>}
    * @memberof AudioApiSearchTracks
    */
    readonly artists?: Array<string>
    
    /**
    * (Deprecated; use bpm_from and bpm_to instead) Show tracks with the specified beats per minute
    * @type {number}
    * @memberof AudioApiSearchTracks
    */
    readonly bpm?: number
    
    /**
    * Show tracks with the specified beats per minute or faster
    * @type {number}
    * @memberof AudioApiSearchTracks
    */
    readonly bpmFrom?: number
    
    /**
    * Show tracks with the specified beats per minute or slower
    * @type {number}
    * @memberof AudioApiSearchTracks
    */
    readonly bpmTo?: number
    
    /**
    * Show tracks with the specified duration in seconds
    * @type {number}
    * @memberof AudioApiSearchTracks
    */
    readonly duration?: number
    
    /**
    * Show tracks with the specified duration or longer in seconds
    * @type {number}
    * @memberof AudioApiSearchTracks
    */
    readonly durationFrom?: number
    
    /**
    * Show tracks with the specified duration or shorter in seconds
    * @type {number}
    * @memberof AudioApiSearchTracks
    */
    readonly durationTo?: number
    
    /**
    * Show tracks with each of the specified genres; to get the list of genres, use `GET /v2/audio/genres`
    * @type {Array<string>}
    * @memberof AudioApiSearchTracks
    */
    readonly genre?: Array<string>
    
    /**
    * Show instrumental music only
    * @type {boolean}
    * @memberof AudioApiSearchTracks
    */
    readonly isInstrumental?: boolean
    
    /**
    * Show tracks with each of the specified instruments; to get the list of instruments, use `GET /v2/audio/instruments`
    * @type {Array<string>}
    * @memberof AudioApiSearchTracks
    */
    readonly instruments?: Array<string>
    
    /**
    * Show tracks with each of the specified moods; to get the list of moods, use `GET /v2/audio/moods`
    * @type {Array<string>}
    * @memberof AudioApiSearchTracks
    */
    readonly moods?: Array<string>
    
    /**
    * Page number
    * @type {number}
    * @memberof AudioApiSearchTracks
    */
    readonly page?: number
    
    /**
    * Number of results per page
    * @type {number}
    * @memberof AudioApiSearchTracks
    */
    readonly perPage?: number
    
    /**
    * One or more search terms separated by spaces
    * @type {string}
    * @memberof AudioApiSearchTracks
    */
    readonly query?: string
    
    /**
    * Sort by
    * @type {'score' | 'ranking_all' | 'artist' | 'title' | 'bpm' | 'freshness' | 'duration'}
    * @memberof AudioApiSearchTracks
    */
    readonly sort?: 'score' | 'ranking_all' | 'artist' | 'title' | 'bpm' | 'freshness' | 'duration'
    
    /**
    * Sort order
    * @type {'asc' | 'desc'}
    * @memberof AudioApiSearchTracks
    */
    readonly sortOrder?: 'asc' | 'desc'
    
    /**
    * Show tracks with the specified vocal description (male, female)
    * @type {string}
    * @memberof AudioApiSearchTracks
    */
    readonly vocalDescription?: string
    
    /**
    * Amount of detail to render in the response
    * @type {'minimal' | 'full'}
    * @memberof AudioApiSearchTracks
    */
    readonly view?: 'minimal' | 'full'
    
    /**
    * Fields to display in the response; see the documentation for the fields parameter in the overview section
    * @type {string}
    * @memberof AudioApiSearchTracks
    */
    readonly fields?: string
    
    /**
    * Which library to search
    * @type {'shutterstock' | 'premier'}
    * @memberof AudioApiSearchTracks
    */
    readonly library?: 'shutterstock' | 'premier'
    
    /**
    * Which language to search in
    * @type {string}
    * @memberof AudioApiSearchTracks
    */
    readonly language?: string
    
}

/**
 * Request parameters for setCollectionName operation in AudioApi.
 * @export
 * @interface AudioApiSetCollectionNameRequest
 */
export type AudioApiSetCollectionNameRequest = {
    
    /**
    * Collection ID
    * @type {string}
    * @memberof AudioApiSetCollectionName
    */
    readonly id: string
    
} & CollectionUpdateRequest

/**
 * AudioApiGenerated - object-oriented interface
 * @export
 * @class AudioApiGenerated
 * @extends {BaseAPI}
 */
export class AudioApiGenerated extends BaseAPI {
    /**
     * This endpoint adds one or more tracks to a collection by track IDs.
     * @summary Add audio tracks to collections
     * @param {AudioApiAddTracksToCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApiGenerated
     */
    public addTracksToCollection(requestParameters: AudioApiAddTracksToCollectionRequest, options?: AxiosRequestConfig) {
        return AudioApiFp(this.configuration).addTracksToCollection(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint creates one or more collections (soundboxes). To add tracks, use `POST /v2/audio/collections/{id}/items`.
     * @summary Create audio collections
     * @param {AudioApiCreateCollectionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApiGenerated
     */
    public createCollections(requestParameters: AudioApiCreateCollectionsRequest, options?: AxiosRequestConfig) {
        return AudioApiFp(this.configuration).createCollections(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint deletes a collection.
     * @summary Delete audio collections
     * @param {AudioApiDeleteCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApiGenerated
     */
    public deleteCollection(requestParameters: AudioApiDeleteCollectionRequest, options?: AxiosRequestConfig) {
        return AudioApiFp(this.configuration).deleteCollection(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gets more detailed information about a collection, including the number of items in it and when it was last updated. To get the tracks in collections, use `GET /v2/audio/collections/{id}/items`.
     * @summary Get the details of audio collections
     * @param {AudioApiGetCollectionDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApiGenerated
     */
    public getCollectionDetails(requestParameters: AudioApiGetCollectionDetailsRequest, options?: AxiosRequestConfig) {
        return AudioApiFp(this.configuration).getCollectionDetails(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint shows information about a track, including its genres, instruments, and other attributes.
     * @summary Get details about audio tracks
     * @param {AudioApiGetTrackDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApiGenerated
     */
    public getTrackDetails(requestParameters: AudioApiGetTrackDetailsRequest, options?: AxiosRequestConfig) {
        return AudioApiFp(this.configuration).getTrackDetails(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gets licenses for one or more tracks. The download links in the response are valid for 8 hours.
     * @summary License audio tracks
     * @param {AudioApiLicenseTracksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApiGenerated
     */
    public licenseTracks(requestParameters: AudioApiLicenseTracksRequest, options?: AxiosRequestConfig) {
        return AudioApiFp(this.configuration).licenseTracks(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint lists existing licenses. You can filter the results according to the track ID to see if you have an existing license for a specific track.
     * @summary List audio licenses
     * @param {AudioApiListAudioLicensesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApiGenerated
     */
    public listAudioLicenses(requestParameters: AudioApiListAudioLicensesRequest = {}, options?: AxiosRequestConfig) {
        return AudioApiFp(this.configuration).listAudioLicenses(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint lists the IDs of tracks in a collection and the date that each was added.
     * @summary Get the contents of audio collections
     * @param {AudioApiListCollectionItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApiGenerated
     */
    public listCollectionItems(requestParameters: AudioApiListCollectionItemsRequest, options?: AxiosRequestConfig) {
        return AudioApiFp(this.configuration).listCollectionItems(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint lists your collections of audio tracks and their basic attributes.
     * @summary List audio collections
     * @param {AudioApiListCollectionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApiGenerated
     */
    public listCollections(requestParameters: AudioApiListCollectionsRequest = {}, options?: AxiosRequestConfig) {
        return AudioApiFp(this.configuration).listCollections(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of all audio genres.
     * @summary List audio genres
     * @param {AudioApiListGenresRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApiGenerated
     */
    public listGenres(requestParameters: AudioApiListGenresRequest = {}, options?: AxiosRequestConfig) {
        return AudioApiFp(this.configuration).listGenres(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of all audio instruments.
     * @summary List audio instruments
     * @param {AudioApiListInstrumentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApiGenerated
     */
    public listInstruments(requestParameters: AudioApiListInstrumentsRequest = {}, options?: AxiosRequestConfig) {
        return AudioApiFp(this.configuration).listInstruments(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of all audio moods.
     * @summary List audio moods
     * @param {AudioApiListMoodsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApiGenerated
     */
    public listMoods(requestParameters: AudioApiListMoodsRequest = {}, options?: AxiosRequestConfig) {
        return AudioApiFp(this.configuration).listMoods(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint lists information about one or more audio tracks, including the description and publication date.
     * @summary List audio tracks
     * @param {AudioApiListTracksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApiGenerated
     */
    public listTracks(requestParameters: AudioApiListTracksRequest, options?: AxiosRequestConfig) {
        return AudioApiFp(this.configuration).listTracks(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint redownloads tracks that you have already received a license for. The download links in the response are valid for 8 hours.
     * @summary Download audio tracks
     * @param {AudioApiRedownloadTracksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApiGenerated
     */
    public redownloadTracks(requestParameters: AudioApiRedownloadTracksRequest, options?: AxiosRequestConfig) {
        return AudioApiFp(this.configuration).redownloadTracks(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint removes one or more tracks from a collection.
     * @summary Remove audio tracks from collections
     * @param {AudioApiRemoveTracksFromCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApiGenerated
     */
    public removeTracksFromCollection(requestParameters: AudioApiRemoveTracksFromCollectionRequest, options?: AxiosRequestConfig) {
        return AudioApiFp(this.configuration).removeTracksFromCollection(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint searches for tracks. If you specify more than one search parameter, the API uses an AND condition. Array parameters can be specified multiple times; in this case, the API uses an AND or an OR condition with those values, depending on the parameter.
     * @summary Search for tracks
     * @param {AudioApiSearchTracksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApiGenerated
     */
    public searchTracks(requestParameters: AudioApiSearchTracksRequest, options?: AxiosRequestConfig) {
        return AudioApiFp(this.configuration).searchTracks(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint sets a new name for a collection.
     * @summary Rename audio collections
     * @param {AudioApiSetCollectionNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApiGenerated
     */
    public setCollectionName(requestParameters: AudioApiSetCollectionNameRequest, options?: AxiosRequestConfig) {
        return AudioApiFp(this.configuration).setCollectionName(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
