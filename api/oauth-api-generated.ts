/* tslint:disable */
/* eslint-disable */
/*
Shutterstock API Explorer

The Shutterstock API provides access to Shutterstock's library of media, as well as information about customers' accounts and the contributors that provide the media.

The version of the OpenAPI document: 1.1.32


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { OauthAccessTokenResponse } from '../models';
// @ts-ignore
import { OauthGetUserAccessTokenRequest } from '../models';
// @ts-ignore
import { OauthGetUserAccessTokenRequest1 } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * OauthApi - axios parameter creator
 * @export
 */
export const OauthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns a redirect URI (in the \'Location\' header) that the customer uses to authorize your application and, together with POST /v2/oauth/access_token, generate an access token that represents that authorization.
         * @summary Authorize applications
         * @param {string} clientId Client ID (Consumer Key) of your application
         * @param {string} redirectUri The callback URI to send the request to after authorization; must use a host name that is registered with your application
         * @param {'code'} responseType Type of temporary authorization code that will be used to generate an access code; the only valid value is \&#39;code\&#39;
         * @param {string} state Unique value used by the calling app to verify the request
         * @param {'customer' | 'contributor'} [realm] User type to be authorized (usually \&#39;customer\&#39;)
         * @param {string} [scope] Space-separated list of scopes to be authorized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeApplications: async (clientId: string, redirectUri: string, responseType: 'code', state: string, realm?: 'customer' | 'contributor', scope?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('authorizeApplications', 'clientId', clientId)
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('authorizeApplications', 'redirectUri', redirectUri)
            // verify required parameter 'responseType' is not null or undefined
            assertParamExists('authorizeApplications', 'responseType', responseType)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('authorizeApplications', 'state', state)
            const localVarPath = `/v2/oauth/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }

            if (realm !== undefined) {
                localVarQueryParameter['realm'] = realm;
            }

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (responseType !== undefined) {
                localVarQueryParameter['response_type'] = responseType;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/oauth/authorize',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns an access token for the specified user and with the specified scopes. The token does not expire until the user changes their password. The body parameters must be encoded as form data.
         * @summary Get access tokens
         * @param {OauthGetUserAccessTokenRequest} [oauthGetUserAccessTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccessToken: async (oauthGetUserAccessTokenRequest?: OauthGetUserAccessTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/oauth/access_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: oauthGetUserAccessTokenRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/oauth/access_token',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(oauthGetUserAccessTokenRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OauthApi - functional programming interface
 * @export
 */
export const OauthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OauthApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns a redirect URI (in the \'Location\' header) that the customer uses to authorize your application and, together with POST /v2/oauth/access_token, generate an access token that represents that authorization.
         * @summary Authorize applications
         * @param {OauthApiAuthorizeApplicationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizeApplications(requestParameters: OauthApiAuthorizeApplicationsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizeApplications(requestParameters.clientId, requestParameters.redirectUri, requestParameters.responseType, requestParameters.state, requestParameters.realm, requestParameters.scope, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns an access token for the specified user and with the specified scopes. The token does not expire until the user changes their password. The body parameters must be encoded as form data.
         * @summary Get access tokens
         * @param {OauthApiGetUserAccessTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAccessToken(requestParameters: OauthApiGetUserAccessTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OauthAccessTokenResponse>> {
            const oauthGetUserAccessTokenRequest: OauthGetUserAccessTokenRequest = {
                client_id: requestParameters.client_id,
                client_secret: requestParameters.client_secret,
                code: requestParameters.code,
                expires: requestParameters.expires,
                grant_type: requestParameters.grant_type,
                realm: requestParameters.realm,
                refresh_token: requestParameters.refresh_token
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAccessToken(oauthGetUserAccessTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OauthApi - factory interface
 * @export
 */
export const OauthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OauthApiFp(configuration)
    return {
        /**
         * This endpoint returns a redirect URI (in the \'Location\' header) that the customer uses to authorize your application and, together with POST /v2/oauth/access_token, generate an access token that represents that authorization.
         * @summary Authorize applications
         * @param {OauthApiAuthorizeApplicationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeApplications(requestParameters: OauthApiAuthorizeApplicationsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authorizeApplications(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns an access token for the specified user and with the specified scopes. The token does not expire until the user changes their password. The body parameters must be encoded as form data.
         * @summary Get access tokens
         * @param {OauthApiGetUserAccessTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccessToken(requestParameters: OauthApiGetUserAccessTokenRequest, options?: AxiosRequestConfig): AxiosPromise<OauthAccessTokenResponse> {
            return localVarFp.getUserAccessToken(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for authorizeApplications operation in OauthApi.
 * @export
 * @interface OauthApiAuthorizeApplicationsRequest
 */
export type OauthApiAuthorizeApplicationsRequest = {
    
    /**
    * Client ID (Consumer Key) of your application
    * @type {string}
    * @memberof OauthApiAuthorizeApplications
    */
    readonly clientId: string
    
    /**
    * The callback URI to send the request to after authorization; must use a host name that is registered with your application
    * @type {string}
    * @memberof OauthApiAuthorizeApplications
    */
    readonly redirectUri: string
    
    /**
    * Type of temporary authorization code that will be used to generate an access code; the only valid value is \'code\'
    * @type {'code'}
    * @memberof OauthApiAuthorizeApplications
    */
    readonly responseType: 'code'
    
    /**
    * Unique value used by the calling app to verify the request
    * @type {string}
    * @memberof OauthApiAuthorizeApplications
    */
    readonly state: string
    
    /**
    * User type to be authorized (usually \'customer\')
    * @type {'customer' | 'contributor'}
    * @memberof OauthApiAuthorizeApplications
    */
    readonly realm?: 'customer' | 'contributor'
    
    /**
    * Space-separated list of scopes to be authorized
    * @type {string}
    * @memberof OauthApiAuthorizeApplications
    */
    readonly scope?: string
    
}

/**
 * Request parameters for getUserAccessToken operation in OauthApi.
 * @export
 * @interface OauthApiGetUserAccessTokenRequest
 */
export type OauthApiGetUserAccessTokenRequest = {
    
} & OauthGetUserAccessTokenRequest

/**
 * OauthApiGenerated - object-oriented interface
 * @export
 * @class OauthApiGenerated
 * @extends {BaseAPI}
 */
export class OauthApiGenerated extends BaseAPI {
    /**
     * This endpoint returns a redirect URI (in the \'Location\' header) that the customer uses to authorize your application and, together with POST /v2/oauth/access_token, generate an access token that represents that authorization.
     * @summary Authorize applications
     * @param {OauthApiAuthorizeApplicationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApiGenerated
     */
    public authorizeApplications(requestParameters: OauthApiAuthorizeApplicationsRequest, options?: AxiosRequestConfig) {
        return OauthApiFp(this.configuration).authorizeApplications(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns an access token for the specified user and with the specified scopes. The token does not expire until the user changes their password. The body parameters must be encoded as form data.
     * @summary Get access tokens
     * @param {OauthApiGetUserAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApiGenerated
     */
    public getUserAccessToken(requestParameters: OauthApiGetUserAccessTokenRequest, options?: AxiosRequestConfig) {
        return OauthApiFp(this.configuration).getUserAccessToken(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
